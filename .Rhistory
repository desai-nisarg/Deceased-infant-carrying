i
capuchin2<-manova(cbind(cap$BH,cap$CS)~cap$Group*cap$Hammer)
summary(capuchin2)
cap<-read.csv(file.choose(), header = TRUE)
capsub<-cap[-10,]
capuchin1<-manova(cbind(cap$A..m.,cap$IV..m.s.,cap$PE..Nm.,cap$KE..Nm.,cap$PWD..k.p..p)~cap$Group+cap$Hammer)
summary(capuchin1)
capuchin3<-manova(cbind(cap$BH,cap$CS)~cap$Group+cap$Hammer)
summary(capuchin3)
pca1<-princomp(capsub[,5:9], cor=TRUE, scale=TRUE)
summary(pca1)
library(devtools)
library(ggbiplot) #See below for descriptions of these commands.
g <- ggbiplot(pca1, groups=capsub$Hammer, ellipse = TRUE, circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', legend.position = 'top')
g
library(geomorph)
install.packages("geomorph")
master<-read.csv(file.choose(), header=TRUE) #Load the data file.
master$gen<- substr(master$cat, 1, 2) #get your gen variable
master$Sex<- substr(master$cat, 4, 4) #get your sex variable
tail(master) #check your work
ncol(master) #count your columns so you can easily execute the next command.
master <- master[ ,c(1,197:198,2:196)] #change the order of your columns so that all categorical vars are at the front and all the landmark data are at the end.
View(master) #Check your work
coordinates<- master[4:198] #create a datafram of just the landmarks
p<- ncol(coordinates)/3 #figure out how many landmarks you have.
p #see how many landmarks you have.
crd<- arrayspecs(coordinates, p, 3) #Convert a matrix of landmark coordinates into a 3-dimensional array so that you can run your gpa
library(rgl)
crd<- arrayspecs(coordinates, p, 3) #Convert a matrix of landmark coordinates into a 3-dimensional array so that you can run your gpa
library(geomorph)
crd<- arrayspecs(coordinates, p, 3) #Convert a matrix of landmark coordinates into a 3-dimensional array so that you can run your gpa
gpa<-gpagen(crd) #Run the GPA
gpa #look at the GPA
gpa$coords #Look at the Procrustes coordinates
gpa$Csize #Look at the centroid for each specimen
gpa$iter #the number of GPA iterations until convergence was found (or GPA halted)
gpa$points.VCV #Var-covar matri among landmark coordinates
gpa$points.var #variances of landmark points
gpa$consensus #The consensus (mean) configuration
gpa$p #number of landmark points
gpa$k #number of landmark dimensions
gpa$nsliders #numebr of semilandmarks along curves
gpa$nsurf #number of semilandmarks on surface points
gpa$data #Data fram with an n x(pk) matrix of Procrustes residuals and centroid size
gpa$Q #final convergence criterion value
gpa$slide.method #method used to slide semilandmarks
gpa$call
#Plot your gpa.
plot(gpa)
library(geomorph)
master<-read.csv(file.choose(), header=TRUE) #Load the data file.
View(master) #check work
str(master) #check work
master$gen<- substr(master$cat, 1, 2) #get your gen variable
master$Sex<- substr(master$cat, 4, 4) #get your sex variable
tail(master) #check your work
ncol(master) #count your columns so you can easily execute the next command.
master <- master[ ,c(1,197:198,2:196)] #change the order of your columns so that all categorical vars are at the front and all the landmark data are at the end.
View(master) #Check your work
coordinates<- master[4:198] #create a datafram of just the landmarks
p<- ncol(coordinates)/3 #figure out how many landmarks you have.
p #see how many landmarks you have.
library(rgl)
crd<- arrayspecs(coordinates, p, 3) #Convert a matrix of landmark coordinates into a 3-dimensional array so that you can run your gpa
gpa<-gpagen(crd) #Run the GPA
gpa #look at the GPA
#Exploreâ€¦
gpa$coords #Look at the Procrustes coordinates
gpa$Csize #Look at the centroid for each specimen
gpa$iter #the number of GPA iterations until convergence was found (or GPA halted)
gpa$points.VCV #Var-covar matri among landmark coordinates
gpa$points.var #variances of landmark points
gpa$consensus #The consensus (mean) configuration
gpa$p #number of landmark points
gpa$k #number of landmark dimensions
gpa$nsliders #numebr of semilandmarks along curves
gpa$nsurf #number of semilandmarks on surface points
gpa$data #Data fram with an n x(pk) matrix of Procrustes residuals and centroid size
gpa$Q #final convergence criterion value
gpa$slide.method #method used to slide semilandmarks
gpa$call
#Plot your gpa.
plot(gpa)
chimps<- master[which(master$gen=="Pt"),] #subset data.
chimps<- droplevels(chimps) #Drop the vestigial factor levels.
View(chimps)
chimpcoords<-chimps[4:198]
q<- ncol(chimpcoords)/3
crdpt<-arrayspecs(chimpcoords,q,3)
gpapt<-gpagen(crdpt)
plot(gpapt)
?ggplot
library(ggplot2)
?ggplot
plots<-read.csv(file.choose())
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
k<-points(plots$PH.x,plots$DEF, cex=0.1, pch=19)
}
}
plot(-1, -1, xlim = c(min(plots$PH.x), max(plots$PH.x)), ylim = c(min(plots$DEF), max(plots$DEF)), xlab = "PH", ylab = "DEF")
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
k<-points(plots$PH.x,plots$DEF, cex=0.1, pch=19)
}
}
p<-ggplot(-1, -1, xlim = c(min(plots$PH.x), max(plots$PH.x)), ylim = c(min(plots$DEF), max(plots$DEF)), xlab = "PH", ylab = "DEF")
p<-ggplot(plots, aes(plots$PH.x, plots$DEF))
p
p<-ggplot(plots, aes(PH.x, DEF))
p
p<-ggplot(plots, aes(PH.x, DEF))
p + geom_point(aes(size = (plots$PH.x, plots$DEF))) + scale_size_area()
datf<-c(plots$PH.x,plots$DEF)
datf<-cbind(plots$PH.x,plots$DEF)
View(datf)
datf<-cbind(plots$PH.x,plots$DEF, head=TRUE)
datf<-cbind(plots$PH.x,plots$DEF)
View(datf)
datf<-as.data.frame(cbind(plots$PH.x,plots$DEF))
View(datf)
dfc <- ddply(datf, c("V1", "V2"), "nrow", .drop = FALSE)
library(plyr)
library(ggplot2)
dfc <- ddply(datf, c("V1", "V2"), "nrow", .drop = FALSE)
View(dfc)
ggplot(data = dfc, aes(x = V1, y = V2, size = factor(nrow))) +
geom_point() +
scale_size_discrete(range = c(1, 10))
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,i+1]<-plots[i,i+1]
}
}
newd<-data.frame()
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,i+1]<-plots[i,i+1]
}
}
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,i+1]<-plots[i,i+1]
}
}
newd[5,6]
newd[5,2]
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
}
for(i in 1:length(plots$Date.x)) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15, na.action()=na.omit()){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
}
newd[0,1]
newd[1,1]
View(newd)
newd[2,1]
newd[2,2]
?if
nj
?if
.
for(i in 1:length(plots$Date.x)+1) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
}
for(i in 1:length(plots$Date.x)-1) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
}
for(i in 1:(length(plots$Date.x)-1) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
}
length(plots$Date.x)-1
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
}
View(newd)
if(plots$Date.x[2]==plots$Date.x[3] && plots$Min[3]-plots$Min[2]==15)
d
if(plots$Date.x[2]==plots$Date.x[3] && plots$Min[3]-plots$Min[2]==15){}
if(plots$Date.x[2]==plots$Date.x[3] && plots$Min[3]-plots$Min[2]==15){12}
if(plots$Date.x[1]==plots$Date.x[2] && plots$Min[2]-plots$Min[1]==15){12}
if(plots$Date.x[2]==plots$Date.x[3] && plots$Min[3]-plots$Min[2]==15){12}
rm(newd)
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
View(newd)
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
else
newd[i,1]<-NA
newd[i,2]<-NA
}
View(newd)
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
else{
newd[i,1]<-NA
newd[i,2]<-NA
}
}
View(newd)
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
else{
newd[i+1,1]<-NA
newd[i+1,2]<-NA
}
}
View(newd)
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && plots$Min[i+1]-plots$Min[i]=15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
else{
newd[i+1,1]<-NA
newd[i+1,2]<-NA
}
}
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && (plots$Min[i+1]-plots$Min[i])==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
else{
newd[i+1,1]<-NA
newd[i+1,2]<-NA
}
}
View(newd)
dfc <- ddply(newd, c("V1", "V2"), "nrow", .drop = FALSE)
View(dfc)
dfc2<-dfc[which(V1!=0),which(V2!=0)]
colnames(dfc,PH,DEF)
?colnames
colnames(dfc)<-c("PH","DEF")
colnames(dfc)<-c("PH","DEF","freq")
dfc2<-dfc[which(dfc$PH!=0),which(dfc$DEF!=0)]
dfc2<-dfc[which(dfc$PH!=0),]
View(dfc2)
dfc2<-dfc[,which(dfc$DEF!=0)]
dfc2<-dfc[which(dfc$DEF!=0),]
ggplot(data = dfc2, aes(x = PH, y = DEF, size = factor(nrow))) +
geom_point() +
scale_size_discrete(range = c(1, 10))
ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEFDEF, size = dfc2$freq)) +
geom_point() +
scale_size_discrete(range = c(1, 10))
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF))
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
View(newd)
View(dfc2)
dfc2<-dfc[which(dfc$PH!=0),]
dfc2<-dfc[which(dfc$DEF!=0),]
dfc2<-dfc[which(dfc$PH!=0),]
dfc2<-dfc2[which(dfc$DEF!=0),]
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF))
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
View(newd)
dfc2<-dfc[which(dfc$DEF!=0),]
View(dfc2)
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF))
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF), xlim(c(0,5)), ylim(c(0,5)))
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF), xlim(c(0,5)), ylim(c(0,5)),  xlab = "PH", ylab = "DEF")
p
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF), xlim(c(0,5)), ylim(c(0,5)),  xlab = "PH", ylab = "DEF")
p
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF), xlim(0,5), ylim(0,5),  xlab = "PH", ylab = "DEF")
p
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF)) +xlim(0,5) + ylim(0,5) +  xlab = "PH"+ ylab = "DEF"
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF)) +xlim(0,5) + ylim(0,5) +  xlab("PH")+ ylab("DEF")
p
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF)) +xlim(0,5) + ylim(0,5) +  xlab("PH")+ ylab("DEF")  +legend("freq")
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF)) +xlim(0,5) + ylim(0,5) +  xlab("PH")+ ylab("DEF")
p + geom_point(aes(size = freq)) + scale_size_area()
p
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
View(dfc)
dfc2<-dfc2[which(dfc$PH!=0),]
p<-ggplot(data = dfc2, aes(x = dfc2$PH, y = dfc2$DEF)) +xlim(0,5) + ylim(0,5) +  xlab("PH")+ ylab("DEF")
p + geom_point(aes(size = dfc2$freq)) + scale_size_area()
?ggolot
p<-ggplot(data = dfc2, aes(x = PH, y = DEF)) +xlim(0,5) + ylim(0,5) +  xlab("PH")+ ylab("DEF")
p + geom_point(aes(size = freq)) + scale_size_area()
dfc <- ddply(newd, c("V1", "V2"), "nrow", .drop = FALSE)
colnames(dfc)<-c("PH","D(EF)","Frequency")
colnames(dfc)<-c("PH","EF arrivals","Frequency")
colnames(dfc)<-c("# PH","EF arrivals","Frequency")
dfc2<-dfc[which(dfc$`EF arrivals`!=0),]
dfc2<-dfc2[which(dfc$`# PH`!=0),]
dfc2<-dfc[which(dfc$`EF arrivals`!=0),]
dfc2<-dfc2[which(dfc$`# PH`!=0),]
p<-ggplot(data = dfc2, aes(x = `# PH`, y = `EF arrivals`)) +xlim(0,5) + ylim(0,5) +  xlab("# Pant-hoots")+ ylab("EF arrivals")
p + geom_point(aes(size = freq)) + scale_size_area()
p + geom_point(aes(size = Frequency)) + scale_size_area()
dfc <- ddply(newd, c("V1", "V2"), "nrow", .drop = FALSE)
dfc2<-dfc[which(dfc$`EF arrivals`!=0),]
p<-ggplot(data = dfc2, aes(x = `# PH`, y = `EF arrivals`)) +xlim(0,5) + ylim(0,5) +  xlab("# Pant-hoots")+ ylab("EF arrivals")
p + geom_point(aes(size = Frequency)) + scale_size_area()
dfc2<-dfc2[which(dfc$`# PH`!=0),]
p<-ggplot(data = dfc2, aes(x = `# PH`, y = `EF arrivals`)) +xlim(0,5) + ylim(0,5) +  xlab("# Pant-hoots")+ ylab("EF arrivals")
p + geom_point(aes(size = Frequency)) + scale_size_area()
newdaf<-as.data.frame(cbind(plots$PH.x,plots$DAF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && (plots$Min[i+1]-plots$Min[i])==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DAF[i]
}
else{
newd[i+1,1]<-NA
newd[i+1,2]<-NA
}
}
newdaf<-as.data.frame(cbind(plots$PH.x,plots$DAF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && (plots$Min[i+1]-plots$Min[i])==15){
newdaf[i,1]<-plots$PH.x[i]
newdaf[i,2]<-plots$DAF[i]
}
else{
newdaf[i+1,1]<-NA
newdaf[i+1,2]<-NA
}
}
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
for(i in 1:9679) {
if(plots$Date.x[i]==plots$Date.x[i+1] && (plots$Min[i+1]-plots$Min[i])==15){
newd[i,1]<-plots$PH.x[i]
newd[i,2]<-plots$DEF[i]
}
else{
newd[i+1,1]<-NA
newd[i+1,2]<-NA
}
}
dfaf <- ddply(newdaf, c("V1", "V2"), "nrow", .drop = FALSE)
View(newdaf)
View(plots)
newdaf<-as.data.frame(cbind(plots$PH.x,plots$DAF))
View(plots)
newdaf<-as.data.frame(cbind(plots$PH.x,plots$DAF))
newd<-as.data.frame(cbind(plots$PH.x,plots$DEF))
View(newd)
cbind(plots$PH.x,plots$DAF)
plots$PH.x
plots$DAF
View(dfc2)
rbind(plots$PH.x,plots$DAF)
cbind(plots$PH.x,plots$DAF)
?cbind
swirl()
library(swirl)
swirl()
library(ape)
library(MCMCglmm)
library(phytools)
library(VGAM)
setwd("~/Desktop/Work/Work/PhD/Sem 3, Fall 2016/5403 Quantitative Methods/Final Paper/")
data<-read.csv("DIC_data.csv",header=TRUE) # Read raw data
data$animal<-gsub(" ", "_", data$species) # Make species names readable by R
data$species<-gsub(" ", "_", data$species) # Make another identical column for additional random effect in MCMCglmm
data$lDIC<-log(data$DIC) # log transform the dependent variable
data1<-data[complete.cases(data),]
phylo<-read.nexus("DIC_consensusTree_1000_Version3.nex")
plot.phylo(phylo, edge.color="red", tip.color="blue", edge.width=2, font=3) # Plot with polytomy
phylo<- drop.tip(phylo, "Pan_paniscus") # Get rid of Pan_paniscus in the tree
plot.phylo(phylo, edge.color="red", tip.color="blue", edge.width=2, font=3)
is.ultrametric(phylo) # Need ultrametric tree
Resolved2<- multi2di(phylo, random=FALSE) # Break polytomy
plot(Resolved2)
finaltree <- compute.brlen(Resolved2, method="Grafen") # Make tree ultrametric
plot.phylo(finaltree, edge.color="red", tip.color="blue", edge.width=2, font=3)
is.ultrametric(finaltree) # Yaay!
prior<-list(G=list(G1=list(V=1,nu=0.02),G2=list(V=1,nu=0.02)),
R=list(V=1,nu=0.02))
formula_1 <- lDIC~Age.Cat+Parity # Model 1 for maternal characteristics
formula_2 <- lDIC~Sex.of.infant+Age.at.death # Model 2 for infant characteristics
formula_3 <- lDIC~Degree.of.arboreality+Condition+Context+T.2 # Model 3 for ecological conditions
fit1a <- MCMCglmm(fixed = formula_1, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
nitt<-1000000
burnin<-100000
thin<-100
fit1a <- MCMCglmm(fixed = formula_1, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
fit1b <- MCMCglmm(fixed = formula_1, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior) # Re-run the model to check for convergence
fit2a <- MCMCglmm(fixed = formula_2, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
fit2b <- MCMCglmm(fixed = formula_2, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior) # Re-run the model to check for convergence
gelman.diag(mcmc.list(fit2a$Sol, fit2b$Sol)) # Check convergence for fixed effects
gelman.diag(mcmc.list(fit2a$VCV, fit2b$VCV)) # Check convergence for random effects
summary(fit2a)
fit3a <- MCMCglmm(fixed = formula_3, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
fit3b <- MCMCglmm(fixed = formula_3, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior) # Re-run the model to check for convergence
summary(fit3a)
gelman.diag(mcmc.list(fit3a$Sol, fit3b$Sol)) # Check convergence for fixed effects
gelman.diag(mcmc.list(fit3a$VCV, fit3b$VCV)) # Check convergence for random effects
H2_fit3<- var(fit3a$VCV[,'animal'])/
(var(fit3a$VCV[,'animal'])+var(fit3a$VCV[,'species'])+
var(fit3a$VCV[,'units'])) #H square is similar to Pagel's lambda
H2_fit2<- var(fit2a$VCV[,'animal'])/
(var(fit2a$VCV[,'animal'])+var(fit2a$VCV[,'species'])+
var(fit2a$VCV[,'units'])) #H square is similar to Pagel's lambda
H2_fit1<- var(fit1a$VCV[,'animal'])/
(var(fit1a$VCV[,'animal'])+var(fit1a$VCV[,'species'])+
var(fit1a$VCV[,'units'])) #H square is similar to Pagel's lambda
summary(fit3b)
rm(list=ls())
data<-read.csv("DIC_data.csv",header=TRUE) # Read raw data
data$animal<-gsub(" ", "_", data$species) # Make species names readable by R
data$species<-gsub(" ", "_", data$species) # Make another identical column for additional random effect in MCMCglmm
data$lDIC<-log(data$DIC) # log transform the dependent variable
u<-mean(data$lDIC)+2*sd(data$lDIC)
l<-mean(data$lDIC)-2*sd(data$lDIC)
doutlier<-data[-which(data$lDIC>u),]
doutlier<-doutlier[-which(doutlier$lDIC<l),]
data1<-doutlier[complete.cases(doutlier),] # Remove rows with missing values
View(data1) # Pan_paniscus is removed
phylo<-read.nexus("DIC_consensusTree_1000_Version3.nex")
plot.phylo(phylo, edge.color="red", tip.color="blue", edge.width=2, font=3) # Plot with polytomy
phylo<- drop.tip(phylo, "Pan_paniscus") # Get rid of Pan_paniscus in the tree
plot.phylo(phylo, edge.color="red", tip.color="blue", edge.width=2, font=3)
is.ultrametric(phylo) # Need ultrametric tree
Resolved2<- multi2di(phylo, random=FALSE) # Break polytomy
plot(Resolved2)
finaltree <- compute.brlen(Resolved2, method="Grafen") # Make tree ultrametric
plot.phylo(finaltree, edge.color="red", tip.color="blue", edge.width=2, font=3)
is.ultrametric(finaltree) # Yaay!
nitt<-240000
burnin<-40000
thin<-100
prior<-list(G=list(G1=list(V=1,nu=0.02),G2=list(V=1,nu=0.02)),
R=list(V=1,nu=0.02))
formula_1 <- lDIC~Age.Cat+Parity # Model 1 for maternal characteristics
formula_2 <- lDIC~Sex.of.infant+Age.at.death # Model 2 for infant characteristics
formula_3 <- lDIC~Degree.of.arboreality+Condition+Context+T.2 # Model 3 for ecological conditions
fit1a <- MCMCglmm(fixed = formula_1, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
fit1b <- MCMCglmm(fixed = formula_1, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior) # Re-run the model to check for convergence
summary(fit1a)
summary(fit1b)
fit1a <- MCMCglmm(fixed = formula_1, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
summary(fit1a)
fit2a <- MCMCglmm(fixed = formula_2, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
fit2b <- MCMCglmm(fixed = formula_2, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior) # Re-run the model to check for convergence
summary(fit2a)
H2_fit1<- var(fit1a$VCV[,'animal'])/
(var(fit1a$VCV[,'animal'])+var(fit1a$VCV[,'species'])+
var(fit1a$VCV[,'units'])) #H square is similar to Pagel's lambda
gelman.diag(mcmc.list(fit2a$Sol, fit2b$Sol)) # Check convergence for fixed effects
gelman.diag(mcmc.list(fit2a$VCV, fit2b$VCV)) # Check convergence for random effects
H2_fit2<- var(fit2a$VCV[,'animal'])/
(var(fit2a$VCV[,'animal'])+var(fit2a$VCV[,'species'])+
var(fit2a$VCV[,'units'])) #H square is similar to Pagel's lambda
fit3a <- MCMCglmm(fixed = formula_3, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior)
fit3b <- MCMCglmm(fixed = formula_3, random=~animal+species, data=data1, pedigree=finaltree,nitt = nitt,
burnin = burnin,thin = thin, prior = prior) # Re-run the model to check for convergence
summary(fit3a)
H2_fit3<- var(fit3a$VCV[,'animal'])/
(var(fit3a$VCV[,'animal'])+var(fit3a$VCV[,'species'])+
var(fit3a$VCV[,'units'])) #H square is similar to Pagel's lambda
rm(list=ls())
library(swirl)
swirl()
